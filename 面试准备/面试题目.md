
# 算法

1. 排序算法
2. 数组去重

# jQuery

1. 链式调用的原理是什么？
2. jQuery的.queue是如何实现的？（非嘲讽，但可能你真的都不一定知道有这个函数）
3. $('div').on('click', 'span a', function(){}) 的本质是什么？如何实现？
4. end方法如何实现的？
5. 为什么jQuery在某个版本后移除了对jQuery对象selector属性的支持？
6. 为什么jQuery某个版本之后不再支持浏览器检测？取而代之的是什么？
7. 数组/jQuery对象上的map，reduce，filter等函数都是如何实现的？
8. 写jQuery代码需要注意些什么？最佳实践有哪些？

# Vue
1. Vue的是如何实现双向绑定的（即响应式数据更新）？
2. 几种表单控件的双向绑定默认都绑定什么类型的数据？能否换为绑定成其它类型的数据？如何做？
3. Vue实例是如何实现代理了其$data属性的访问的？为什么vm.$data.ary[0] = 8这样的代码不会触发视图的更新？为什么vm.$data.ary = [8]又可以呢？
4. 计算属性是什么？它会在何时更新？它如何知道自己应该在何时更新？计算属性最终实际被Vue转换成了什么？
5. v-model的本质是什么？组件如何实现一个自己自定义的v-model？
6. 递归组件写过吗？
7. 父组件如何向子组件传递数据？反过来呢？

# [JS编译原理 --《你不知道的JS》](https://www.cnblogs.com/linwx/articles/7688517.html)

## 1.编译原理

### 	1.分词/词法分析

​		这些代码块被称为词法单元（token）。例如，var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;

### 	2.解析/语法分析

​		这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST） 　　　　



```
<script>
         variabledeclaration

    identifier = a      assignmentExpession

                                        numricliteral  =2
</script>
```



### 	3.代码生成

​		将AST转换为可执行代码的过程称被称为代码生成 。

## 3.编译原理的重要角色

　　**引擎**
　　　　从头到尾负责整个JavaScript程序的编译及执行过程。
　　**编译****器**
　　　　引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
　　**作用域**
　　　　引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

## 4.RHS和LHS查询

　　如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询

## 5.错误类型

　　ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。







# [词法作用域 --《你不知道的JS》](https://www.cnblogs.com/linwx/articles/7689019.html)

## 1.什么是词法作用域？

　　词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变 。

## 2.欺骗词法

> 怎么在才能在运行中 “修改”词法作用域呢？？



　　答案：JavaScript中有两种机制实现这个目的，不过值得注意的是欺骗词法作用域会导致性能下降

　　**两种机制如下**

### 　　1.eval() 函数    ---魔鬼

　　　　函数可以接受一个字符串为参数，这个字符相当于可以运行的JavaScript代码，在执行eval之后，引擎并不知道eval是以动态的方式进入的，并对词法环境进行修改。

```
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

　　在执行eval之后，var b = 2; 会生成一个词法环境，即在foo作用域里面定义了b变量，console.log访问时首先会在自己的词法作用域里寻找a，b变量。类似的有setTimeout(),setInterval();

### 　　3.with()

　　　　　　with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。



```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```



### 　　3.性能

　　JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符 。如果引擎在代码中发现了eval(..)或with.

它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。



# [函数作用域和块级作用域 --《你不知道JS》](https://www.cnblogs.com/linwx/articles/7694941.html)

## **函数作用域**

　　1.函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用） 。

　　2.避免函数变量冲突，隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突；

　　3.可通过**立即执行函数和匿名函数等解决变量冲突问题；**

## **2.块作用域**

　　在表面上看JavaScript没有块级作用域，但深入研究有些可以看作是块级作用域。

　　1.with()

　　　　用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效 .

　　2.try/catch

　　　　ECMA3规范中规定try/catch的catch分句会创建一个块级作用域，其声明的变量仅在catch分句中有效；



```
try {
    undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
    console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```



## **3.let**

　　ECMA6引入了let,提供除了var以外的另一种变量声明方式。let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let可以声明块级变量。 在for 循环中应用广泛



```
    var foo = true;
    if (foo) {
    et bar = foo * 2;
    bar = something( bar );
    console.log( bar );
}
    console.log( bar ); // ReferenceError
```



　　**注意：但是使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。**

```
{
    console.log( bar ); // ReferenceError!
    let bar = 2;
}
```



　　**其**非常有用的原因和垃圾回收机制有关，引擎可以清楚地知道要不要回收变量。

## **4.const**

　　ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（**常量**）。之后任何试图修改值的操作都会引起错误



